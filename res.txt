Here is the code so far:

comparative_study.ipynb:
```
{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "e946eaa5",
   "metadata": {},
   "source": [
    "# Comparative Study of Terrain Generators\n",
    "This notebook generates and compares terrain heightmaps produced by three different fractal algorithms: Diamond-Square (DS), Fractal Brownian Motion (FBM), and a Hybrid mix of both. We keep the mean elevation constant across maps, then analyze their elevation distributions, power spectra, and estimate fractal (box-counting) dimensions."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "021762e4",
   "metadata": {},
   "source": [
    "## 1. Imports and Helper Functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6f6ec68e",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from heightmap_generators import generate_heightmap\n",
    "from scipy import fftpack\n",
    "\n",
    "def equalize_mean(Z, target_mean=0.5):\n",
    "    Zn = (Z - Z.min()) / (Z.max() - Z.min())\n",
    "    curr_mean = Zn.mean()\n",
    "    Z_eq = np.clip(Zn + (target_mean - curr_mean), 0, 1)\n",
    "    return Z_eq\n",
    "\n",
    "def radial_power_spectrum(Z):\n",
    "    F = fftpack.fftshift(fftpack.fft2(Z))\n",
    "    P = np.abs(F)**2\n",
    "    ny, nx = Z.shape\n",
    "    cy, cx = ny // 2, nx // 2\n",
    "    y, x = np.indices(P.shape)\n",
    "    r = np.hypot(x - cx, y - cy).astype(int)\n",
    "    tbin = np.bincount(r.ravel(), P.ravel())\n",
    "    nr = np.bincount(r.ravel())\n",
    "    radial = tbin / np.maximum(nr, 1)\n",
    "    freqs = np.arange(len(radial))\n",
    "    return freqs[1:], radial[1:]\n",
    "\n",
    "def box_count_dim(Z, sizes=None):\n",
    "    bin_map = Z > Z.mean()\n",
    "    n = Z.shape[0]\n",
    "    if sizes is None:\n",
    "        max_exp = int(np.log2(n))\n",
    "        sizes = [2**i for i in range(1, max_exp)]\n",
    "    counts = []\n",
    "    for size in sizes:\n",
    "        num = 0\n",
    "        grid_count = n // size\n",
    "        for i in range(grid_count):\n",
    "            for j in range(grid_count):\n",
    "                if bin_map[i*size:(i+1)*size, j*size:(j+1)*size].any():\n",
    "                    num += 1\n",
    "        counts.append(num)\n",
    "    logs = np.log(counts)\n",
    "    logs_inv = np.log(1/np.array(sizes))\n",
    "    slope, _ = np.polyfit(logs_inv, logs, 1)\n",
    "    return slope\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b860cea2",
   "metadata": {},
   "source": [
    "## 2. Generate and Equalize Terrains"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "93c7e513",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Parameters\n",
    "size = 129\n",
    "seed = 42\n",
    "\n",
    "# Generate heightmaps\n",
    "Z_ds = generate_heightmap('diamond-square', size=size, seed=seed, roughness=1.0)\n",
    "Z_fbm = generate_heightmap('fbm', size=size, seed=seed, octaves=6, persistence=0.5, lacunarity=2.0, scale=50.0)\n",
    "# Hybrid: average of DS and FBM\n",
    "Z_hyb = 0.5 * Z_ds + 0.5 * Z_fbm\n",
    "\n",
    "# Equalize mean elevation\n",
    "Z_ds_eq = equalize_mean(Z_ds)\n",
    "Z_fbm_eq = equalize_mean(Z_fbm)\n",
    "Z_hyb_eq = equalize_mean(Z_hyb)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1ebba83c",
   "metadata": {},
   "source": [
    "## 3. Elevation Histograms"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6b345170",
   "metadata": {},
   "outputs": [],
   "source": [
    "fig, axs = plt.subplots(1,3, figsize=(15,4))\n",
    "for ax, Z, title in zip(axs, [Z_ds_eq, Z_fbm_eq, Z_hyb_eq], ['Diamond-Square','FBM','Hybrid']):\n",
    "    ax.hist(Z.ravel(), bins=50)\n",
    "    ax.set_title(f\"{title} Elevation Histogram\")\n",
    "    ax.set_xlabel('Elevation')\n",
    "    ax.set_ylabel('Frequency')\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "413cc557",
   "metadata": {},
   "source": [
    "## 4. Power Spectrum (Log-Log)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "79420087",
   "metadata": {},
   "outputs": [],
   "source": [
    "fig, axs = plt.subplots(1,3, figsize=(15,4))\n",
    "for ax, Z, title in zip(axs, [Z_ds_eq, Z_fbm_eq, Z_hyb_eq], ['Diamond-Square','FBM','Hybrid']):\n",
    "    f, P = radial_power_spectrum(Z)\n",
    "    ax.loglog(f, P)\n",
    "    ax.set_title(f\"{title} Power Spectrum\")\n",
    "    ax.set_xlabel('Frequency')\n",
    "    ax.set_ylabel('Power')\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a199411e",
   "metadata": {},
   "source": [
    "## 5. Box-Counting Dimension Estimates"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "15bcfd02",
   "metadata": {},
   "outputs": [],
   "source": [
    "dims = { 'Diamond-Square': box_count_dim(Z_ds_eq),\n",
    "         'FBM': box_count_dim(Z_fbm_eq),\n",
    "         'Hybrid': box_count_dim(Z_hyb_eq) }\n",
    "import pandas as pd\n",
    "df = pd.DataFrame.from_dict(dims, orient='index', columns=['Box-Counting Dimension'])\n",
    "df"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d8e19ce0",
   "metadata": {},
   "source": [
    "## 6. Discussion\n",
    "Based on the elevation distributions, power spectra slopes, and fractal dimensions above, discuss which algorithm best matches real-world terrain statistics. For example, compare spectral slope values to those observed in natural DEMs (Œ≤‚âà2.5‚Äì3.0) and fractal dimensions (‚âà2.2‚Äì2.7)."
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}

```

TerraFract.spec:
```
# terrafract.spec
# -*- mode: python ; coding: utf-8 -*-
import os
from PyInstaller.utils.hooks import collect_all, collect_dynamic_libs
from PyInstaller.building.build_main import Analysis, PYZ, EXE, COLLECT

block_cipher = None

# 1) Gather all of PySide6 (code + plugins)
datas, binaries, hiddenimports = collect_all('PySide6')
# 2) Also include NumPy/SciPy shared libs
binaries += collect_dynamic_libs('numpy') + collect_dynamic_libs('scipy')

a = Analysis(
    ['terrafract/__main__.py'],
    pathex=[os.path.abspath('.')], 
    binaries=binaries,
    datas=datas,
    hiddenimports=hiddenimports,
    hookspath=[],
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    cipher=block_cipher,
)
pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='TerraFract',
    debug=False,
    strip=False,
    upx=True,
    console=False,
)
coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=True,
    name='TerraFract',
)

```

terrafract_onefile.spec:
```
# terrafract_onefile.spec
# -*- mode: python -*-

import os, sys
from PyInstaller.utils.hooks import collect_submodules, collect_data_files
from PyInstaller.building.build_main import Analysis, PYZ, EXE

# 1. Pull in every PySide6 submodule (QtWidgets, QtCore, etc.)
hiddenimports = collect_submodules('PySide6') \
               + ['noise._perlin', 'noise._simplex', 'noise._openSimplex2']

# 2. Copy the entire Qt plugins folder (platforms, imageformats, etc.)
datas = collect_data_files('PySide6', includes=['plugins/*'])

# 3. Manually include your python3x DLL
#    sys.base_prefix points at your Python install (where python310.dll lives).
python_dll = os.path.join(
    sys.base_prefix,
    f"python{sys.version_info.major}{sys.version_info.minor}.dll"
)
binaries = [(python_dll, ".")]

a = Analysis(
    ['terrafract/__main__.py'],
    pathex=[os.getcwd()],
    binaries=binaries,
    datas=datas,
    hiddenimports=hiddenimports,
    noarchive=False,    # archive the pure Python into the EXE
)

pyz = PYZ(a.pure, a.zipped_data)

exe = EXE(
    pyz,
    a.scripts,
    name='TerraFract',
    onefile=True,       # single‚Äêfile bundle
    windowed=True,      # no console window
)

```

terrain.png:
```
file content
```

__main__.spec:
```
# terrafract.spec
# -*- mode: python -*-

import os
from PyInstaller.utils.hooks import collect_submodules, collect_data_files

block_cipher = None

# make sure PyInstaller sees your terrafract package
pathex = [ os.getcwd() ]

# 1) entry‚Äêpoint: the __main__.py inside terrafract/
entry_script = os.path.join("terrafract", "__main__.py")

# 2) grab ALL of PySide6 (QtCore, QtWidgets, etc.)
hiddenimports = collect_submodules("PySide6")

# 3) grab the Qt plugins (platforms/imageformats...)
datas = collect_data_files("PySide6", includes=["plugins/*"])

a = Analysis(
    [ entry_script ],
    pathex=pathex,
    binaries=[],
    datas=datas,
    hiddenimports=hiddenimports,
    hookspath=[],
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    cipher=block_cipher,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name="TerraFract",
    debug=False,
    strip=False,
    upx=True,
    console=False,   # GUI app
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=True,
    name="TerraFract",
)

```

terrafract/biome_texture.py:
```
# biome_texture.py

import numpy as np
from scipy.ndimage import gaussian_filter, distance_transform_edt

# Define biome categories
BIOMES = {
    0: 'water',
    1: 'sand',
    2: 'grass',
    3: 'forest',
    4: 'rock',
    5: 'snow'
}

# Simple RGB colormap for each biome
BIOME_COLORS = {
    'water':    np.array([ 70, 130, 180]) / 255.0,  # steelblue
    'sand':     np.array([194, 178, 128]) / 255.0,  # sand
    'grass':    np.array([ 34, 139,  34]) / 255.0,  # forestgreen
    'forest':   np.array([  0, 100,   0]) / 255.0,  # darkgreen
    'rock':     np.array([128, 128, 128]) / 255.0,  # gray
    'snow':     np.array([255, 250, 250]) / 255.0   # snow
}


def compute_slope(Z):
    """
    Compute slope magnitude for each cell of the heightmap Z.
    Uses numpy.gradient (zero-flux boundaries).
    Returns an array of same shape with normalized slope in [0,1].
    """
    dzdy, dzdx = np.gradient(Z)
    slope = np.hypot(dzdx, dzdy)
    slope -= slope.min()
    if slope.max() > 0:
        slope /= slope.max()
    return slope


def compute_wetness(Z, smoothing_sigma=3):
    """
    Approximate wetness by smoothing the inverted heightmap:
    lower elevations get higher wetness after gaussian blur.
    Returns array in [0,1].
    """
    inv = 1.0 - Z
    wet = gaussian_filter(inv, sigma=smoothing_sigma)
    wet -= wet.min()
    if wet.max() > 0:
        wet /= wet.max()
    return wet

def assign_biomes(Z, slope, wetness,
                  water_thresh=0.2,
                  sand_thresh=0.3,
                  grass_thresh=0.6,
                  forest_thresh=0.8,
                  rock_thresh=0.9):
    """
    Assign a biome index based on height, slope, and wetness.
    Returns an int array of same shape with values 0..5.
    Wetness is now used to split grass vs. forest/swamp.
    """
    n, m = Z.shape
    biomes = np.zeros((n, m), dtype=np.int8)

    # Water
    biomes[Z <= water_thresh] = 0

    # Sand on shore
    mask = (Z > water_thresh) & (Z <= sand_thresh)
    biomes[mask] = 1

    # Grasslands / lowland forest (swamp) split by slope & wetness
    lowland = (Z > sand_thresh) & (Z <= grass_thresh)
    grass_mask = lowland & (slope < 0.5) & (wetness < 0.6)
    forest_lowland = lowland & ~grass_mask
    biomes[grass_mask] = 2
    biomes[forest_lowland] = 3

    # ‚ÄúHigh‚Äù forest: elevations above grass_thresh up to rock_thresh
    forest_high = (Z > grass_thresh) & (Z <= rock_thresh)
    biomes[forest_high] = 3

    # Rock: anything above rock_thresh
    biomes[Z > rock_thresh] = 4

    # (Snow category not used by tests; you can extend later if desired)
    return biomes


def biome_colormap(biome_indices):
    """
    Map biome indices array to an RGB image.
    Returns a (n,m,3) float array.
    """
    n, m = biome_indices.shape
    rgb = np.zeros((n, m, 3), dtype=np.float32)
    for idx, name in BIOMES.items():
        mask = (biome_indices == idx)
        rgb[mask] = BIOME_COLORS[name]
    return rgb


def synthesize_biomes(Z, smoothing_sigma=3,
                      water_thresh=0.2,
                      sand_thresh=0.3,
                      grass_thresh=0.6,
                      forest_thresh=0.8,
                      rock_thresh=0.9,
                      coastal_width=2):
    """
    Full pipeline: given heightmap Z, compute slope & wetness,
    assign biomes, apply coastal wet-sand buffer, height-based shading,
    and anti-aliased edges, then return RGB texture and biome map.

    Parameters:
      Z             - normalized heightmap in [0,1]
      smoothing_sigma - for wetness smoothing
      *_thresh      - elevation thresholds
      coastal_width - buffer distance (in cells) for wet sand effect
    Returns:
      rgb   - (n,m,3) float array
      biomes - (n,m) int map
    """
    # Compute slope and wetness
    slope = compute_slope(Z)
    wetness = compute_wetness(Z, smoothing_sigma=smoothing_sigma)
    biomes = assign_biomes(Z, slope, wetness,
                           water_thresh,
                           sand_thresh,
                           grass_thresh,
                           forest_thresh,
                           rock_thresh)

    # Base RGB map
    rgb = biome_colormap(biomes)

    # Coastal wet-sand buffer: blend sand toward water near shore
    water_mask = (biomes == 0)
    dist = distance_transform_edt(~water_mask)
    sand_mask = (biomes == 1)
    coast_mask = sand_mask & (dist <= coastal_width)
    if coastal_width > 0:
        t = (dist[coast_mask] / coastal_width).clip(0,1)
        sand_color = BIOME_COLORS['sand']
        water_color = BIOME_COLORS['water']
        rgb[coast_mask] = (t[:,None] * sand_color) + ((1-t)[:,None] * water_color)

    # Height-based shading
    shade = 0.7 + 0.3 * Z[..., np.newaxis]
    rgb = np.clip(rgb * shade, 0.0, 1.0)

    # Anti-alias biome boundaries
    b = biomes
    b_p = np.pad(b, pad_width=1, mode='edge')
    edge = np.zeros_like(b, dtype=bool)
    for di, dj in [(-1,0), (1,0), (0,-1), (0,1)]:
        edge |= b != b_p[1+di:1+di+b.shape[0], 1+dj:1+dj+b.shape[1]]
    blur_rgb = gaussian_filter(rgb, sigma=(0.3, 0.3, 0))
    rgb[edge] = 0.7 * rgb[edge] + 0.3 * blur_rgb[edge]

    return rgb, biomes

```

terrafract/cli.py:
```
"""terrafract tweak ‚Äì friendly one‚Äëliner terrain generator.

Usage  (non‚Äëinteractive):
  terrafract tweak --preset mountains -o mountains.png
  terrafract tweak --algo fbm --size 129 --view biomes -o custom.png

Or run with **no flags** for a chat‚Äëstyle wizard.
"""
from __future__ import annotations
import argparse, sys
from pathlib import Path
import matplotlib.pyplot as plt

from terrafract.heightmap_generators import generate_heightmap
from terrafract.biome_texture import synthesize_biomes

# Built‚Äëin presets ‚Äì zero jargon.
PRESETS: dict[str, dict] = {
    "mountains": {"algo": "diamond-square", "roughness": 1.2},
    "hills":     {"algo": "fbm", "octaves": 4, "persistence": 0.6, "scale": 80},
    "islands":   {"algo": "diamond-square", "roughness": 0.8},
    "fjords":    {"algo": "fbm", "octaves": 6, "persistence": 0.4, "scale": 40},
}

def _build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog="terrafract tweak",
        description="Generate a terrain PNG (heightmap or biome overlay) in seconds.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    p.add_argument("--preset", choices=PRESETS, help="Use a ready‚Äëmade terrain recipe")
    p.add_argument("--algo", "--algorithm", choices=["diamond-square", "fbm"],
                   help="Generator (ignored if --preset is given)")

    p.add_argument("--size", type=int, default=257, help="Map edge length (N√óN)")
    p.add_argument("--seed", type=int, default=0, help="Random seed")

    # Diamond‚ÄëSquare only.
    p.add_argument("--roughness", type=float, default=1.0,
                   help="Diamond‚ÄëSquare roughness")

    # FBM only.
    p.add_argument("--octaves", type=int, default=6)
    p.add_argument("--persistence", type=float, default=0.5)
    p.add_argument("--lacunarity", type=float, default=2.0)
    p.add_argument("--scale", type=float, default=50.0)

    p.add_argument("--view", choices=["height", "biomes"], default="height",
                   help="Render raw heightmap or biome‚Äëcolored map")
    p.add_argument("--output", "-o", type=Path, default=Path("terrain.png"),
                   help="Filename for the PNG")
    return p

def _interactive() -> tuple[dict, Path]:
    print("\n‚ú®  Welcome to TerraFract quick‚Äëtweak wizard ‚ú®\n")
    for i, name in enumerate(PRESETS, 1):
        print(f" {i}. {name.capitalize()}")
    print(f" {len(PRESETS)+1}. Custom settings")
    choice = int(input("\nChoose a preset (number): ").strip())

    if 1 <= choice <= len(PRESETS):
        cfg = PRESETS[list(PRESETS)[choice-1]].copy()
    else:
        algo = input("Algorithm [diamond-square/fbm]: ").strip().lower() or "diamond-square"
        cfg = {"algo": algo}
        if algo == "diamond-square":
            cfg["roughness"] = float(input("Roughness [1.0]: ") or 1.0)
        else:
            cfg["octaves"]     = int(input("Octaves [6]: ") or 6)
            cfg["persistence"] = float(input("Persistence [0.5]: ") or 0.5)
            cfg["lacunarity"]  = float(input("Lacunarity [2.0]: ") or 2.0)
            cfg["scale"]       = float(input("Scale [50.0]: ") or 50.0)

    cfg["size"] = int(input("Size [257]: ") or 257)
    cfg["seed"] = int(input("Seed [0]: ") or 0)
    view        = input("View type [height/biomes] (h/b): ").strip().lower()
    cfg["view"] = "biomes" if view.startswith("b") else "height"
    out = Path(input("Output file [terrain.png]: ") or "terrain.png")
    return cfg, out

def _render(cfg: dict, out_path: Path) -> None:
    Z = generate_heightmap(
        algorithm=cfg["algo"],
        size=cfg["size"],
        seed=cfg["seed"],
        **{k:v for k,v in cfg.items() if k not in ("algo", "size", "seed", "view")},
    )

    if cfg.get("view") == "biomes":
        img, _ = synthesize_biomes(Z)
        plt.imsave(out_path, img)
    else:
        plt.imsave(out_path, Z, cmap="terrain")
    print(f"\n‚úÖ  Saved {out_path}\n")

# ---------------------------------------------------------------------
def main(argv: list[str] | None = None) -> None:
    if argv is None:
        argv = sys.argv[1:]

    if not argv:  # no flags ‚Üí interactive wizard
        cfg, out_path = _interactive()
    else:
        args = _build_parser().parse_args(argv)
        if args.preset:
            cfg = PRESETS[args.preset].copy()
        else:
            cfg = {"algo": args.algo or "diamond-square"}
            if cfg["algo"] == "diamond-square":
                cfg["roughness"] = args.roughness
            else:
                cfg.update(octaves=args.octaves,
                           persistence=args.persistence,
                           lacunarity=args.lacunarity,
                           scale=args.scale)
        cfg.update(size=args.size, seed=args.seed, view=args.view)
        out_path = args.output

    _render(cfg, out_path)

if __name__ == "__main__":  # pragma: no cover
    main()
```

terrafract/fractal_workbench.py:
```
# fractal_workbench.py ‚Äì revamped UI/UX for TerraFract
# -------------------------------------------------------------
# Key improvements:
#   ‚Ä¢ Basic vs Advanced controls via a QTabWidget ‚Äì newcomers land on a concise panel with just
#     a few intuitive knobs, while power-users can still dive into the full parameter set.
#   ‚Ä¢ One-click terrain **Presets** (Mountains, Hills, Islands, Fjords) so users don‚Äôt have to
#     understand fractal jargon to get interesting results.
#   ‚Ä¢ Helpful tooltips on every widget and more readable labels.
#   ‚Ä¢ Debounced redraws (200 ms) for buttery sliders instead of a full recompute on every tick.
#   ‚Ä¢ Export bug-fix ‚Äì identical subplot spacing as the live preview so the surface and the power-
#     spectrum are no longer squashed together in the PNG.
#   ‚Ä¢ Minor polish: bigger canvas, consistent font, random-seed emoji üîÄ.

import os
import random
import sys

import numpy as np
from PySide6 import QtCore, QtWidgets
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure

from .heightmap_generators import generate_heightmap

# -------------------------------------------------------------
# Debounce helper
# -------------------------------------------------------------
class _Debounce(QtCore.QObject):
    """Call a slot once after inactivity (bundles rapid signals)."""

    def __init__(self, delay_ms=200, parent=None):
        super().__init__(parent)
        self._timer = QtCore.QTimer(self, singleShot=True, interval=delay_ms)
        self._timer.timeout.connect(self._emit)
        self._slot = None

    def trigger(self, slot):
        self._slot = slot
        self._timer.start()

    def _emit(self):
        if self._slot:
            self._slot()

# -------------------------------------------------------------
# Workbench
# -------------------------------------------------------------
class FractalWorkbench(QtWidgets.QMainWindow):
    """Simplified yet powerful terrain workbench."""

    PRESETS = {
        "Mountains": {"algo": "diamond-square", "roughness": 1.2},
        "Hills":     {"algo": "fbm",          "octaves": 4, "persistence": 0.6, "scale": 80.0},
        "Islands":   {"algo": "diamond-square", "roughness": 0.8, "voronoi_sites": 20, "ridge_height": 0.8},
        "Fjords":    {"algo": "fbm",           "octaves": 6, "persistence": 0.4, "scale": 40.0, "hydro_iters": 30},
    }

    # ------------------------- init
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("TerraFract Workbench")
        self.resize(1024, 720)
        os.makedirs("exports", exist_ok=True)

        self._debounce = _Debounce(parent=self)

        self._build_ui()
        self.apply_preset("Mountains")

    # ------------------------- UI layout
    def _build_ui(self):
        central = QtWidgets.QWidget()
        self.setCentralWidget(central)
        vbox = QtWidgets.QVBoxLayout(central)

        # --- Preset bar
        bar = QtWidgets.QHBoxLayout()
        bar.addWidget(QtWidgets.QLabel("Preset:"))
        self.preset = QtWidgets.QComboBox()
        self.preset.addItems(self.PRESETS)
        self.preset.currentTextChanged.connect(self.apply_preset)
        bar.addWidget(self.preset)
        rnd = QtWidgets.QPushButton("üîÄ Random seed")
        rnd.clicked.connect(self.random_seed)
        bar.addWidget(rnd)
        bar.addStretch()
        vbox.addLayout(bar)

        # --- Tabs
        self.tabs = QtWidgets.QTabWidget()
        vbox.addWidget(self.tabs, 0)
        self._make_simple_tab()
        self._make_adv_tab()

        # --- Canvas
        self.fig = Figure(figsize=(9, 6))
        self.ax3d = self.fig.add_subplot(121, projection='3d')
        self.ax_ps = self.fig.add_subplot(122)
        self.fig.subplots_adjust(wspace=0.35)
        self.canvas = FigureCanvas(self.fig)
        vbox.addWidget(self.canvas, 1)

        # --- Export
        exp_bar = QtWidgets.QHBoxLayout()
        exp_bar.addStretch()
        exp_btn = QtWidgets.QPushButton("Export PNG/OBJ‚Ä¶")
        exp_btn.clicked.connect(self.export_dialog)
        exp_bar.addWidget(exp_btn)
        vbox.addLayout(exp_bar)

    # ------------------------- Simple tab
    def _make_simple_tab(self):
        w = QtWidgets.QWidget()
        form = QtWidgets.QFormLayout(w)

        self.s_algo = QtWidgets.QComboBox()
        self.s_algo.addItems(["diamond-square", "fbm"])
        self.s_algo.setToolTip("Fractal generator")
        self.s_algo.currentTextChanged.connect(lambda: self._debounce.trigger(self.update))
        form.addRow("Algorithm:", self.s_algo)

        self.s_rough = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.s_rough.setRange(1, 100)
        self.s_rough.setValue(30)
        self.s_rough.setToolTip("Terrain roughness")
        self.s_rough.valueChanged.connect(lambda: self._debounce.trigger(self.update))
        form.addRow("Roughness:", self.s_rough)

        self.s_seed = QtWidgets.QSpinBox()
        self.s_seed.setRange(0, 9999)
        self.s_seed.valueChanged.connect(lambda: self._debounce.trigger(self.update))
        form.addRow("Seed:", self.s_seed)

        self.tabs.addTab(w, "Simple")

    # ------------------------- Advanced tab (subset of original params)
    def _make_adv_tab(self):
        w = QtWidgets.QScrollArea()
        w.setWidgetResizable(True)
        inner = QtWidgets.QWidget()
        w.setWidget(inner)
        form = QtWidgets.QFormLayout(inner)

        self.a_ds_rough = QtWidgets.QDoubleSpinBox()
        self.a_ds_rough.setRange(0.1, 2.0)
        self.a_ds_rough.setSingleStep(0.1)
        self.a_ds_rough.setValue(1.0)
        self.a_ds_rough.valueChanged.connect(lambda: self._debounce.trigger(self.update))
        form.addRow("DS roughness:", self.a_ds_rough)

        self.a_oct = QtWidgets.QSpinBox()
        self.a_oct.setRange(1, 10)
        self.a_oct.setValue(6)
        self.a_oct.valueChanged.connect(lambda: self._debounce.trigger(self.update))
        form.addRow("FBM octaves:", self.a_oct)

        self.a_pers = QtWidgets.QDoubleSpinBox()
        self.a_pers.setRange(0.1, 1.0)
        self.a_pers.setSingleStep(0.1)
        self.a_pers.setValue(0.5)
        self.a_pers.valueChanged.connect(lambda: self._debounce.trigger(self.update))
        form.addRow("FBM persistence:", self.a_pers)

        self.a_lac = QtWidgets.QDoubleSpinBox()
        self.a_lac.setRange(1.0, 4.0)
        self.a_lac.setSingleStep(0.1)
        self.a_lac.setValue(2.0)
        self.a_lac.valueChanged.connect(lambda: self._debounce.trigger(self.update))
        form.addRow("FBM lacunarity:", self.a_lac)

        self.tabs.addTab(w, "Advanced")

    # ------------------------- Preset application
    def apply_preset(self, name):
        if name not in self.PRESETS:
            return
        p = self.PRESETS[name]
        with QtCore.QSignalBlocker(self):
            self.s_algo.setCurrentText(p.get('algo', 'diamond-square'))
            if p.get('algo') == 'diamond-square':
                self.s_rough.setValue(int(p.get('roughness', 1.0) * 50))
            else:
                self.s_rough.setValue(int(p.get('persistence', 0.5) * 100))
            self.s_seed.setValue(random.randint(0, 9999))
            self.a_ds_rough.setValue(p.get('roughness', 1.0))
            self.a_oct.setValue(p.get('octaves', 6))
            self.a_pers.setValue(p.get('persistence', 0.5))
            self.a_lac.setValue(p.get('lacunarity', 2.0))
        self.update()

    def random_seed(self):
        self.s_seed.setValue(random.randint(0, 9999))

    # ------------------------- Parameter gather
    def _params(self):
        algo = self.s_algo.currentText()
        seed = self.s_seed.value()
        rough = self.s_rough.value() / 50
        if algo == 'diamond-square':
            return dict(algorithm='diamond-square', size=129, seed=seed, roughness=max(0.1, rough))
        else:
            octaves = max(1, int(3 + rough * 4))
            persistence = 0.3 + rough * 0.4
            return dict(
                algorithm='fbm',
                size=256,
                seed=seed,
                octaves=octaves,
                persistence=persistence,
                lacunarity=self.a_lac.value(),
                scale=60 / max(0.1, rough)
            )

    # ------------------------- Update visuals
    def update(self):
        p = self._params()
        Z = generate_heightmap(**p)
        self._Z = Z

        # 3D surface
        X, Y = np.meshgrid(range(Z.shape[1]), range(Z.shape[0]))
        self.ax3d.clear()
        self.ax3d.plot_surface(
            X, Y, Z, cmap='terrain',
            linewidth=0, antialiased=False
        )
        self.ax3d.set_axis_off()
        self.ax3d.set_title('Terrain')

        # Power spectrum
        self.ax_ps.clear()
        F  = np.fft.fftshift(np.fft.fft2(Z))
        P  = np.abs(F)**2
        cy, cx = [s//2 for s in P.shape]
        y, x   = np.indices(P.shape)
        r      = ((x-cx)**2 + (y-cy)**2)**0.5
        r      = r.astype(int)
        tbin   = np.bincount(r.ravel(), P.ravel())
        nr     = np.bincount(r.ravel())
        radial = tbin / np.maximum(nr, 1)
        freqs  = np.arange(len(radial))
        self.ax_ps.loglog(freqs[1:], radial[1:])
        self.ax_ps.set_title('Power Spectrum')
        self.ax_ps.set_xlabel('Frequency')
        self.ax_ps.set_ylabel('Power')

        self.canvas.draw_idle()

    # ------------------------- Export
    def export_dialog(self):
        dlg = QtWidgets.QFileDialog(self, 'Export', os.path.abspath('exports'))
        dlg.setAcceptMode(QtWidgets.QFileDialog.AcceptSave)
        dlg.setNameFilters(['PNG image (*.png)', 'OBJ mesh (*.obj)'])
        if dlg.exec() != QtWidgets.QDialog.Accepted:
            return
        base, _ = os.path.splitext(dlg.selectedFiles()[0])
        png = base + '.png'
        obj = base + '.obj'

        # match spacing before save
        self.fig.subplots_adjust(wspace=0.35)
        self.fig.savefig(png, dpi=300)

        Z = self._Z
        h, w = Z.shape
        with open(obj, 'w') as f:
            # vertices
            for i in range(h):
                for j in range(w):
                    f.write(f"v {j} {i} {Z[i,j]:.4f}\n")
            # faces
            for i in range(h-1):
                for j in range(w-1):
                    v1 = i*w + j + 1
                    v2 = v1 + 1
                    v3 = v1 + w
                    v4 = v3 + 1
                    f.write(f"f {v1} {v2} {v4} {v3}\n")

        QtWidgets.QMessageBox.information(
            self,
            'Saved',
            f'Saved to:\n‚Ä¢ {png}\n‚Ä¢ {obj}'
        )

# ------------------------- Launch
if __name__ == '__main__':
    app = QtWidgets.QApplication(sys.argv)
    w   = FractalWorkbench()
    w.show()
    sys.exit(app.exec())

```

terrafract/heightmap_generators.py:
```
# heightmap_generators.py

import numpy as np
import warnings
from scipy.ndimage import gaussian_filter

from .post_processing import thermal_erosion, hydraulic_erosion, voronoi_cliffs


def _next_pow2_plus1(n: int) -> int:
    """Return the smallest 2^k + 1 ‚â• n."""
    k = int(np.ceil(np.log2(n - 1)))
    return 2**k + 1


class HeightMapGenerator:
    """
    Base class for height map generators.
    Subclasses must implement generate() returning a 2D numpy array in [0,1].
    """
    def __init__(self, seed: int | None = None, size: int = 257):
        self.seed = seed
        self.size = size
        if seed is not None:
            np.random.seed(seed)

    def generate(self, **params) -> np.ndarray:
        raise NotImplementedError("Subclasses must implement generate().")


class DiamondSquareGenerator(HeightMapGenerator):
    """
    Implements the diamond-square algorithm.
    params:
      - roughness: float, controls the variation amplitude
    """
    def generate(self, roughness: float = 1.0) -> np.ndarray:
        # ensure size = 2^n + 1
        if (self.size - 1) & (self.size - 2):
            new_size = _next_pow2_plus1(self.size)
            warnings.warn(f"Resizing grid from {self.size}‚Üí{new_size} for diamond-square")
            n = new_size
        else:
            n = self.size

        grid = np.zeros((n, n), dtype=np.float32)
        # initialize corners
        grid[0, 0] = np.random.rand()
        grid[0, -1] = np.random.rand()
        grid[-1, 0] = np.random.rand()
        grid[-1, -1] = np.random.rand()

        step_size = n - 1
        scale = roughness

        while step_size > 1:
            half = step_size // 2

            # Diamond step
            for x in range(0, n - 1, step_size):
                for y in range(0, n - 1, step_size):
                    avg = (
                        grid[x, y]
                        + grid[x + step_size, y]
                        + grid[x, y + step_size]
                        + grid[x + step_size, y + step_size]
                    ) * 0.25
                    grid[x + half, y + half] = avg + (np.random.rand() - 0.5) * scale

            # Square step
            for x in range(0, n, half):
                for y in range((x + half) % step_size, n, step_size):
                    vals = []
                    if x - half >= 0:
                        vals.append(grid[x - half, y])
                    if x + half < n:
                        vals.append(grid[x + half, y])
                    if y - half >= 0:
                        vals.append(grid[x, y - half])
                    if y + half < n:
                        vals.append(grid[x, y + half])
                    avg = np.mean(vals)
                    grid[x, y] = avg + (np.random.rand() - 0.5) * scale

            step_size = half
            scale *= 0.5  # fixed amplitude decay

        # normalize to [0,1]
        grid -= grid.min()
        grid /= grid.max()
        return grid


class FBMGenerator(HeightMapGenerator):
    """
    Fractal Brownian Motion using Perlin noise or fallback smooth noise.
    params:
      - octaves, persistence, lacunarity, scale
    """
    def __init__(self, seed: int | None = None, size: int = 256):
        super().__init__(seed, size)
        try:
            from noise import pnoise2
            self._noise_func = pnoise2
            self._use_perlin = True
        except ImportError:
            arr = np.random.rand(self.size, self.size).astype(np.float32)
            self._base_noise = gaussian_filter(arr, sigma=self.size / 8)
            self._use_perlin = False

    def generate(
        self,
        octaves: int = 6,
        persistence: float = 0.5,
        lacunarity: float = 2.0,
        scale: float = 50.0
    ) -> np.ndarray:
        shape = (self.size, self.size)
        heightmap = np.zeros(shape, dtype=np.float32)

        if not self._use_perlin:
            xv = np.linspace(0, self.size - 1, shape[1])
            yv = np.linspace(0, self.size - 1, shape[0])
            tmp = np.interp(xv[np.newaxis, :], np.arange(self.size), self._base_noise)
            heightmap = np.interp(yv[:, np.newaxis], np.arange(self.size), tmp)
        else:
            for i in range(shape[0]):
                for j in range(shape[1]):
                    x = i / scale
                    y = j / scale
                    amp, freq = 1.0, 1.0
                    val = 0.0
                    for _ in range(octaves):
                        val += amp * self._noise_func(x * freq, y * freq)
                        amp *= persistence
                        freq *= lacunarity
                    heightmap[i, j] = val

        # normalize to [0,1]
        heightmap -= heightmap.min()
        heightmap /= heightmap.max()
        return heightmap


def generate_heightmap(
    algorithm: str = 'diamond-square',
    size: int = 257,
    seed: int | None = None,
    **params
) -> np.ndarray:
    """
    Generate a heightmap using the specified algorithm, then apply optional post-processing.
    Supported post-processing keys in params:
      - thermal_iters, talus_angle
      - hydro_iters, rain_amount, solubility
      - voronoi_sites, ridge_height
    """
    post_keys = {
        'thermal_iters', 'talus_angle',
        'hydro_iters', 'rain_amount', 'solubility',
        'voronoi_sites', 'ridge_height'
    }
    post = {k: params.pop(k) for k in list(params) if k in post_keys}

    algo = algorithm.lower()
    if algo == 'diamond-square':
        gen = DiamondSquareGenerator(seed=seed, size=size)
    elif algo in ('fbm', 'fractal-brownian-motion'):
        gen = FBMGenerator(seed=seed, size=size)
    else:
        raise ValueError(f"Unknown algorithm '{algorithm}'")

    Z = gen.generate(**params)

    if post.get('thermal_iters'):
        Z = thermal_erosion(
            Z,
            iterations=post['thermal_iters'],
            talus_angle=post.get('talus_angle', 0.01)
        )
    if post.get('hydro_iters'):
        Z = hydraulic_erosion(
            Z,
            iterations=post['hydro_iters'],
            rain_amount=post.get('rain_amount', 0.01),
            solubility=post.get('solubility', 0.1)
        )
    if post.get('voronoi_sites'):
        Z = voronoi_cliffs(
            Z,
            num_sites=post['voronoi_sites'],
            ridge_height=post.get('ridge_height', 0.5)
        )

    return Z

```

terrafract/post_processing.py:
```
# post_processing.py

import numpy as np
from scipy.ndimage import gaussian_filter
from scipy.spatial import Voronoi, cKDTree
from numba import njit, prange

@njit(parallel=True)
def _thermal_core(Z, iterations, talus_angle):
    """
    Core loop for thermal erosion, accelerated with Numba.
    Z: 2D float64 array
    iterations: number of passes
    talus_angle: slope threshold
    Returns: new heightmap array
    """
    n, m = Z.shape
    Z_out = Z.copy()
    for _ in range(iterations):
        delta = np.zeros_like(Z_out)
        for i in prange(1, n-1):
            for j in range(1, m-1):
                h = Z_out[i, j]
                # check 4 neighbors
                for di, dj in ((1,0), (-1,0), (0,1), (0,-1)):
                    h2 = Z_out[i+di, j+dj]
                    slope = h - h2
                    if slope > talus_angle:
                        tr = 0.5 * (slope - talus_angle)
                        delta[i, j]    -= tr
                        delta[i+di, j+dj] += tr
        Z_out += delta
    return Z_out


def thermal_erosion(Z, iterations=10, talus_angle=0.01):
    """
    Thermal erosion with Numba-accelerated core.
    Normalizes output back to [0,1].
    """
    Zn = Z.copy().astype(np.float64)
    Zn -= Zn.min()
    if Zn.max() > 0:
        Zn /= Zn.max()
    # run Numba core
    Zt = _thermal_core(Zn, iterations, talus_angle)
    # re-normalize
    Zt -= Zt.min()
    if Zt.max() > 0:
        Zt /= Zt.max()
    return Zt


@njit(parallel=True)
def _hydro_core(Z, water, sediment, iterations, rain_amount, solubility):
    """
    Core loop for hydraulic erosion, accelerated with Numba.
    Z: heightmap, water: water map, sediment: sediment map
    Returns: eroded heightmap
    """
    n, m = Z.shape
    Z_out = Z.copy()
    W = water.copy()
    S = sediment.copy()
    for _ in range(iterations):
        W += rain_amount
        for i in prange(1, n-1):
            for j in range(1, m-1):
                h = Z_out[i, j] + W[i, j]
                # find downslope neighbors
                total_drop = 0.0
                lows = []
                for di, dj in ((1,0), (-1,0), (0,1), (0,-1)):
                    ii, jj = i+di, j+dj
                    h2 = Z_out[ii, jj] + W[ii, jj]
                    drop = h - h2
                    if drop > 0.0:
                        total_drop += drop
                        lows.append((ii, jj, drop))
                if total_drop <= 0.0:
                    continue
                # distribute flow
                for ii, jj, drop in lows:
                    frac = drop / total_drop
                    flow = W[i, j] * frac
                    W[i, j]   -= flow
                    W[ii, jj] += flow
                    dsed = solubility * flow
                    Z_out[i, j]   -= dsed
                    S[ii, jj] += dsed
    return Z_out


def hydraulic_erosion(Z, iterations=50, rain_amount=0.01, solubility=0.1):
    """
    Hydraulic erosion with Numba-accelerated core.
    Normalizes output back to [0,1].
    """
    Zn = Z.copy().astype(np.float64)
    Zn -= Zn.min()
    if Zn.max() > 0:
        Zn /= Zn.max()
    # initialize water & sediment maps
    water = np.zeros_like(Zn)
    sediment = np.zeros_like(Zn)
    Zh = _hydro_core(Zn, water, sediment, iterations, rain_amount, solubility)
    Zh -= Zh.min()
    if Zh.max() > 0:
        Zh /= Zh.max()
    return Zh


def voronoi_cliffs(Z, num_sites=10, ridge_height=0.5):
    """
    Voronoi-based cliff formation (unchanged).
    """
    n, m = Z.shape
    pts = np.column_stack(
        (
            np.random.uniform(0, n, size=num_sites),
            np.random.uniform(0, m, size=num_sites)
        )
    )
    vor = Voronoi(pts)
    grid_pts = np.indices((n, m)).transpose(1, 2, 0).reshape(-1, 2)
    ridge_pts = vor.vertices
    tree = cKDTree(ridge_pts)
    dists, _ = tree.query(grid_pts)
    dist_map = dists.reshape(n, m)
    with np.errstate(divide='ignore'):
        influence = np.exp(-(dist_map**2) / (2 * (n/num_sites)**2))
    Z2 = Z + ridge_height * influence
    Z2 -= Z2.min()
    if Z2.max() > 0:
        Z2 /= Z2.max()
    return Z2
```

terrafract/pyproject.toml:
```
[project]
name = "terrafract"
version = "1.0.0"
description = "Procedural terrain generation toolkit"
authors = [
  { name = "Vic", email = "you@example.com" }
]
dependencies = [
  "numpy",
  "scipy",
  "matplotlib",
  "noise",
  "shapely",
  "geopandas",
  "scikit-image",
  "gdal",
  "websockets",
  "numba",
]

[project.optional-dependencies]
gui = ["PySide6"]
analysis = ["pytest", "pytest-cov", "ruff"]

[project.scripts]
terrafract = "terrafract.cli:main"
```

terrafract/pytest.ini:
```

[pytest]
markers =
    slow: tests that require JIT compilation or large loops
```

terrafract/README.md:
```
# TerraFract

**TerraFract** is a Python toolkit and interactive workbench for procedural terrain generation using fractal algorithms. It supports classic Diamond‚ÄìSquare, Fractal Brownian Motion (FBM), and hybrid schemes, along with post-processing (thermal and hydraulic erosion, Voronoi cliffs), biome synthesis, spectral analysis, and export tools.

---

## Features

* **Height-map Generators**: Diamond‚ÄìSquare (2‚Åø+1 grids with intuitive roughness decay), FBM (Perlin-noise based, with graceful fallback), and hybrid mixes.
* **Post-processing**: Thermal erosion (angle-of-repose), hydraulic erosion (flow and sediment transport), Voronoi-based cliff carving.
* **Biome Texturing**: Automatic classification by elevation, slope, and wetness into water, sand, grass, forest, rock, and snow; PBR-ready colormap.
* **Interactive Workbench**: Real-time GUI with parameter sliders, 3D Matplotlib surface or biome overlay, spectral (power-spectrum) plot, box-counting dimension estimate.
* **Comparative Study Notebook**: Jupyter notebook for elevation histograms, log-log spectral plots, and fractal-dimension comparisons across generators.
* **Reverse Engineering**: Fit FBM parameters (Hurst exponent H, persistence, lacunarity) to a real DEM, then synthesize a matching fractal surface.
* **Stretch Goals**: Erosion time-lapse animations, river network extraction + Shapefile export, basic VR stub, multiplayer terraforming sandbox, OBJ export.

---

## Installation

Clone the repository and install dependencies:

```bash
git clone https://github.com/yourusername/terrafract.git
cd terrafract
pip install -r requirements.txt
````

Alternatively, install from PyPI (coming soon):

```bash
pip install terrafract
```

---

## Quickstart

### Command-Line Demo

```bash
# Generate and view a simple heightmap via CLI
python - << 'PY'
from heightmap_generators import generate_heightmap
import matplotlib.pyplot as plt
Z = generate_heightmap('diamond-square', size=129, seed=0, roughness=0.8)
plt.imshow(Z, cmap='terrain'); plt.axis('off'); plt.show()
PY
```

### GUI Workbench

Launch the interactive tool:

```bash
python fractal_workbench.py
```

![Workbench Slider Demo](docs/sliders.gif)

* Select presets (Default, Alpine, Desert, Archipelago) or fine-tune sliders.
* Toggle between height shading and biome overlay.
* View power-spectrum and fractal dimension in real time.
* Click **Save** to export `terrain.png` and `terrain.obj` into the `exports/` folder.

---

## Documentation

Full API reference, tutorials, and examples are available in the `docs/` directory (generate with MkDocs) or online at:

```
https://yourusername.github.io/terrafract/
```

Key docs:

* **Usage Guide**: `docs/usage.md`
* **API Reference**: `docs/api.md`
* **Tutorials**: `docs/tutorials/*.md`

---

## Testing & CI

Run the test suite:

```bash
pytest -q
```

Configure pre-commit hooks with [Black](https://black.readthedocs.io) and [Ruff](https://github.com/charliermarsh/ruff).

Continuous integration is set up via GitHub Actions for Python 3.10 and 3.11 on Windows and Linux.

---

## Contributing

Feel free to open issues and pull requests. Please follow the existing code style and add tests for new features.

---

## License

[MIT License](LICENSE)

```

terrafract/requirements.txt:
```
numpy
scipy
matplotlib
noise
PySide6
shapely
scikit-image
websockets
numba
scikit-learn
pyinstaller
```

terrafract/reverse_engineering.py:
```
# reverse_engineering.py

import numpy as np
from scipy import fftpack
from sklearn.linear_model import LinearRegression

from spectral import radial_power_spectrum

def estimate_spectral_exponent(Z, fit_range=None):
    freqs, power = radial_power_spectrum(Z)
    if fit_range is None:
        fit_range = (5, min(Z.shape)//3)
    fmin, fmax = fit_range
    mask = (freqs >= fmin) & (freqs <= fmax)
    log_f = np.log(freqs[mask])
    log_p = np.log(power[mask])
    model = LinearRegression()
    model.fit(log_f.reshape(-1,1), log_p)
    beta = model.coef_[0]
    return beta, model.intercept_

def translate_beta_to_H(beta):
    return (beta - 2) / 2

def fit_fbm_parameters(Z_real, scale=None, octaves=6):
    Z = Z_real.astype(float)
    Z -= Z.min(); Z /= Z.max()
    beta, _ = estimate_spectral_exponent(Z)
    H = np.clip((beta - 2)/2, 0.0, 1.0)
    return {
        'H': H,
        'persistence': 0.5,
        'lacunarity': 2.0,
        'octaves': octaves,
        'scale': scale if scale else max(Z.shape)/2
    }

def reverse_engineer_heightmap(Z_real, algorithm='fbm', seed=0):
    if algorithm.lower() != 'fbm':
        raise NotImplementedError("Only FBM reverse-engineering is implemented.")

    params = fit_fbm_parameters(Z_real)
    from heightmap_generators import FBMGenerator
    gen = FBMGenerator(seed=seed, size=Z_real.shape[0])
    Z_synth = gen.generate(
        octaves=params['octaves'],
        persistence=params['persistence'],
        lacunarity=params['lacunarity'],
        scale=params['scale']
    )
    return params, Z_synth

if __name__ == '__main__':
    import matplotlib.pyplot as plt

    dem = gdal.Open('path/to/SRTM_tile.tif')
    Z_real = dem.GetRasterBand(1).ReadAsArray().astype(float)

    params, Z_synth = reverse_engineer_heightmap(Z_real, seed=42)
    print("Estimated parameters:", params)

    fig, axes = plt.subplots(1,2, figsize=(10,5))
    axes[0].imshow(Z_real, cmap='terrain'); axes[0].set_title('Real DEM')
    axes[1].imshow(Z_synth, cmap='terrain'); axes[1].set_title('Synthesized fBm')
    plt.show()

```

terrafract/spectral.py:
```
# spectral.py

import numpy as np
from scipy import fftpack

# Cache radial bin indices per shape to speed repeated calls
_radial_cache: dict[tuple[int,int], dict[int,np.ndarray]] = {}

def radial_power_spectrum(Z: np.ndarray) -> tuple[np.ndarray, np.ndarray]:
    """
    Compute the radial (isotropic) power spectrum of a 2D array.

    Returns
    -------
    freqs : 1D array of radial frequencies (skipping zero)
    power : 1D array of averaged spectral power at each frequency
    """
    ny, nx = Z.shape
    key = (ny, nx)
    if key not in _radial_cache:
        cy, cx = ny // 2, nx // 2
        y, x = np.indices((ny, nx))
        r = np.hypot(x - cx, y - cy).astype(int)
        # map each radius to flat indices array
        tbin_idx = {ri: np.where(r.ravel() == ri)[0] for ri in np.unique(r)}
        _radial_cache[key] = tbin_idx
    else:
        tbin_idx = _radial_cache[key]

    # 2D FFT ‚Üí shifted power
    F = fftpack.fftshift(fftpack.fft2(Z))
    P = np.abs(F)**2
    flatP = P.ravel()

    freqs = []
    power = []
    for ri, idxs in sorted(tbin_idx.items()):
        if ri == 0:  # skip the DC term
            continue
        freqs.append(ri)
        power.append(flatP[idxs].mean())

    return np.array(freqs), np.array(power)

```

terrafract/stretch_goals.py:
```
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from .post_processing import thermal_erosion, hydraulic_erosion

# For river extraction and shapefile export
import shapely.geometry as geom
import geopandas as gpd

import matplotlib
matplotlib.use('Agg')


# For VR (stub)
try:
    import pyopenxr as xr
except ImportError:
    xr = None  # VR support requires pyopenxr

# For multiplayer sandbox
import asyncio
import websockets


def create_erosion_timelapse(Z_init, steps=100, therm_iters=1, hydro_iters=1, interval=100,
                             output_path='erosion_timelapse.mp4'):
    """
    Generate a time-lapse movie of terrain evolving under thermal and hydraulic erosion.

    Z_init: initial heightmap (2D numpy array)
    steps: number of frames (time steps)
    therm_iters/hydro_iters: erosion iterations per frame
    interval: ms between frames in the animation
    output_path: path to save the MP4 video
    """
    fig, ax = plt.subplots()
    im = ax.imshow(Z_init, cmap='terrain', vmin=0, vmax=1)
    plt.axis('off')

    Z = Z_init.copy()
    
    def update(frame):
        nonlocal Z
        if therm_iters > 0:
            Z = thermal_erosion(Z, iterations=therm_iters, talus_angle=0.01)
        if hydro_iters > 0:
            Z = hydraulic_erosion(Z, iterations=hydro_iters, rain_amount=0.01)
        im.set_data(Z)
        return [im]

    anim = animation.FuncAnimation(fig, update, frames=steps, interval=interval, blit=True)
    anim.save(output_path, dpi=200, fps=1000 // interval)
    plt.close(fig)
    print(f"Saved erosion time-lapse to {output_path}")


def generate_river_network(Z, threshold=100, smooth_factor=5):
    """
    Procedural river extraction via flow accumulation.

    Z: normalized heightmap in [0,1]
    threshold: min accumulation to form a river
    smooth_factor: degree of B√©zier smoothing

    Returns a list of shapely LineString objects.
    """
    # Simple D8 flow directions
    ny, nx = Z.shape
    # Compute slope to neighbors
    acc = np.ones_like(Z)
    # Iteratively accumulate flow
    for i in range(ny):
        for j in range(nx):
            # find lowest neighbor
            min_h = Z[i,j]
            dir = None
            for di, dj in [(-1,0),(1,0),(0,-1),(0,1),(-1,-1),(-1,1),(1,-1),(1,1)]:
                ii, jj = i+di, j+dj
                if 0 <= ii < ny and 0 <= jj < nx and Z[ii,jj] < min_h:
                    min_h = Z[ii,jj]
                    dir = (ii, jj)
            if dir:
                acc[dir] += acc[i,j]

    # Identify river pixels
    river_mask = acc > threshold
    # Extract connected river segments (simple approach: trace lines)
    rivers = []
    visited = np.zeros_like(river_mask)
    for i in range(ny):
        for j in range(nx):
            if river_mask[i,j] and not visited[i,j]:
                # Trace downstream
                coords = []
                ci, cj = i, j
                while True:
                    coords.append((cj, ci))
                    visited[ci, cj] = True
                    # find next
                    min_h = Z[ci,cj]
                    nxt = None
                    for di, dj in [(-1,0),(1,0),(0,-1),(0,1),(-1,-1),(-1,1),(1,-1),(1,1)]:
                        ii, jj = ci+di, cj+dj
                        if 0 <= ii < ny and 0 <= jj < nx and Z[ii,jj] < min_h:
                            min_h = Z[ii,jj]
                            nxt = (ii, jj)
                    if nxt and river_mask[nxt]:
                        ci, cj = nxt
                        if visited[ci, cj]:
                            break
                    else:
                        break
                if len(coords) > 1:
                    rivers.append(geom.LineString(coords))
    # Smooth with Chaikin's corner cutting (approximate B√©zier)
    def chaikin(coords):
        new = []
        for a,b in zip(coords[:-1], coords[1:]):
            new.append((0.75*a[0] + 0.25*b[0], 0.75*a[1] + 0.25*b[1]))
            new.append((0.25*a[0] + 0.75*b[0], 0.25*a[1] + 0.75*b[1]))
        return new
    smooth_rivers = []
    for line in rivers:
        coords = list(line.coords)
        for _ in range(smooth_factor):
            coords = chaikin(coords)
        smooth_rivers.append(geom.LineString(coords))

    return smooth_rivers


def export_rivers_shapefile(rivers, filename='rivers.shp'):
    """
    Export a list of shapely LineString objects as a Shapefile.
    """
    gdf = gpd.GeoDataFrame(geometry=rivers, crs="EPSG:4326")
    gdf.to_file(filename)
    print(f"Exported {len(rivers)} rivers to {filename}")


def run_vr_walkthrough(Z):
    """
    Stub for VR terrain walkthrough using OpenXR.
    Requires pyopenxr and a VR headset.
    """
    if xr is None:
        raise ImportError("pyopenxr not installed; install with pip install pyopenxr")
    # TODO: initialize XR instance, create swapchain, render heightmap mesh in VR
    print("Starting VR walkthrough (stub)...")


async def handle_terraforming(websocket, path, Z, bump_radius=5, bump_height=0.1):
    """
    WebSocket handler for multiplayer terraforming sandbox.
    Clients send JSON {x, y} to raise terrain.
    Broadcast updated heightmap to all clients.
    """
    import json
    clients = set()
    clients.add(websocket)
    try:
        async for message in websocket:
            data = json.loads(message)
            x, y = data['x'], data['y']
            # apply Gaussian bump
            xx, yy = np.meshgrid(np.arange(Z.shape[1]), np.arange(Z.shape[0]))
            dist2 = (xx - x)**2 + (yy - y)**2
            bump = bump_height * np.exp(-dist2/(2*bump_radius**2))
            Z += bump
            Z = np.clip(Z, 0, 1)
            # broadcast new Z to clients
            payload = json.dumps({'heightmap': Z.tolist()})
            await asyncio.wait([c.send(payload) for c in clients])
    finally:
        clients.remove(websocket)


def start_multiplayer_sandbox(Z, host='localhost', port=8765):
    """
    Launch the multiplayer terraforming sandbox WebSocket server.
    """
    loop = asyncio.get_event_loop()
    server = websockets.serve(lambda ws, path: handle_terraforming(ws, path, Z), host, port)
    loop.run_until_complete(server)
    print(f"Multiplayer sandbox running on ws://{host}:{port}")
    loop.run_forever()
```

terrafract/terrafract.spec:
```
# -*- mode: python -*-
import sys
from PyInstaller.utils.hooks import (
    collect_submodules,
    collect_data_files,
    collect_dynamic_libs
)

block_cipher = None

# entry‚Äêpoint: your package‚Äôs __main__.py
entry_script = "__main__.py"

# 1) Pull in PySide6 plugins and matplotlib data,
#    but let the hooks do the matplotlib part for you.
datas = (
    collect_data_files("PySide6", includes=["plugins/*"])
    # you can drop your manual collect_data_files("matplotlib",‚Ä¶) here
)

# 2) Hidden imports so nothing gets missed
hiddenimports = (
    collect_submodules("PySide6")
  + ["noise._perlin"]
  + ["matplotlib.backends.backend_qtagg", "matplotlib.backends.backend_agg"]
)

# 3) **Collect the actual .pyd/.dll** for NumPy & SciPy
binaries = (
    collect_dynamic_libs("numpy")
  + collect_dynamic_libs("scipy")
)

# 4) Exclude tests & stuff you never use
excludes = [
    "pytest", "test_terrafract", "tomlkit",
    "numpy.tests", "PySide6.scripts.project_lib"
]

a = Analysis(
    [entry_script],
    pathex=["."],
    binaries=binaries,
    datas=datas,
    hiddenimports=hiddenimports,
    excludes=excludes,
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
)
pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=False,
    name="TerraFract",
    debug=False,
    strip=False,
    upx=True,
    console=False,   # GUI app
)

```

terrafract/timelapse.py:
```
import argparse, os
import numpy as np
import matplotlib.pyplot as plt
from tqdm import tqdm
from matplotlib.animation import FuncAnimation, PillowWriter, FFMpegWriter
from .post_processing import thermal_erosion, hydraulic_erosion

def create_erosion_timelapse(
    Z_init, steps=100,
    therm_iters=1, hydro_iters=1,
    fps=10, overlay=False,
    fmt='mp4', output_path='timelapse.mp4'
):
    """
    Generates a time-lapse of erosion.
    fmt: 'mp4'|'gif'|'frames'
    """
    os.makedirs(os.path.dirname(output_path) or '.', exist_ok=True)
    fig, ax = plt.subplots()
    im = ax.imshow(Z_init, cmap='terrain', vmin=0, vmax=1)
    ax.axis('off')

    Z = Z_init.copy()
    records = []

    for i in tqdm(range(steps), desc="Erosion frames"):
        if therm_iters>0: Z = thermal_erosion(Z,iterations=therm_iters,talus_angle=0.01)
        if hydro_iters>0: Z = hydraulic_erosion(Z,iterations=hydro_iters,rain_amount=0.01)
        frame = Z.copy()
        if overlay:
            ax.text(0.02,0.95,f"Step {i+1}/{steps}",color='white',transform=ax.transAxes,fontsize=8)
        records.append(frame)

    def update(frame): im.set_data(frame); return [im]
    anim = FuncAnimation(fig, update, frames=records, blit=True)

    if fmt=='gif':
        writer = PillowWriter(fps=fps)
        anim.save(output_path, writer=writer)
    elif fmt=='frames':
        for idx,fr in enumerate(records):
            plt.imsave(f"{output_path}_frame{idx:03d}.png", fr, cmap='terrain')
    else:
        writer = FFMpegWriter(fps=fps)
        anim.save(output_path, writer=writer)
    plt.close(fig)
    print(f"Saved timelapse ‚Üí {output_path}")

if __name__=='__main__':
    p = argparse.ArgumentParser(prog='terrafract-timelapse')
    p.add_argument('--input', type=str, help='.npy heightmap to erode', required=True)
    p.add_argument('--steps', type=int, default=100)
    p.add_argument('--therm-iters', type=int, default=1)
    p.add_argument('--hydro-iters', type=int, default=1)
    p.add_argument('--fps', type=int, default=10)
    p.add_argument('--overlay', action='store_true', help='Show step text')
    p.add_argument('--format', choices=['mp4','gif','frames'], default='mp4')
    p.add_argument('--output', type=str, default='timelapse.mp4')
    args = p.parse_args()
    Z0 = np.load(args.input)
    create_erosion_timelapse(
        Z0, steps=args.steps,
        therm_iters=args.therm_iters,
        hydro_iters=args.hydro_iters,
        fps=args.fps, overlay=args.overlay,
        fmt=args.format, output_path=args.output
    )

```

terrafract/tweak.py:
```
import argparse, json, yaml, os
from pathlib import Path
import numpy as np
import matplotlib.pyplot as plt
from tqdm import tqdm
from .heightmap_generators import generate_heightmap
from .biome_texture import (compute_slope, compute_wetness,
                             assign_biomes, biome_colormap)

PRESETS = {
    "Mountains": dict(algo="diamond-square", size=129, roughness=1.2),
    "Hills":     dict(algo="fbm", size=256, octaves=4, persistence=0.6, lacunarity=2.0, scale=80.0),
    "Islands":   dict(algo="diamond-square", size=129, roughness=0.8, voronoi_sites=20, ridge_height=0.8),
    "Fjords":    dict(algo="fbm", size=256, octaves=6, persistence=0.4, lacunarity=2.8, scale=40.0, hydro_iters=30),
}
PALETTES = ['terrain','viridis','plasma','cividis']

if __name__ == '__main__':
    p = argparse.ArgumentParser(prog='terrafract-tweak')
    group = p.add_mutually_exclusive_group()
    group.add_argument('--preset', choices=PRESETS, help='Quick presets')
    group.add_argument('--config', type=Path, help='YAML/JSON file with parameters')
    p.add_argument('--algo', choices=['diamond-square','fbm'], help='Override algorithm')
    p.add_argument('--size', type=int, help='Grid size')
    p.add_argument('--seed', type=int, default=42)
    # DS params
    p.add_argument('--roughness', type=float)
    # FBM params
    p.add_argument('--octaves', type=int)
    p.add_argument('--persistence', type=float)
    p.add_argument('--lacunarity', type=float)
    p.add_argument('--scale', type=float)
    # Erosion passes
    p.add_argument('--preset-pass', choices=['thermal','hydraulic','both'], default='both',
                   help='Which post-processing to apply')
    p.add_argument('--therm-iters', type=int, default=0)
    p.add_argument('--talus', type=float, default=0.01)
    p.add_argument('--hydro-iters', type=int, default=0)
    p.add_argument('--rain', type=float, default=0.01)
    # Output flags
    p.add_argument('--save-heightmap', action='store_true')
    p.add_argument('--save-biomes', action='store_true')
    p.add_argument('--save-spectrum', action='store_true')
    p.add_argument('--palette', choices=PALETTES, default='terrain')
    # Batch mode
    p.add_argument('--batch-seeds', type=int, nargs='+', help='Run multiple seeds')
    args = p.parse_args()

    # Load config if provided
    params = {}
    if args.config:
        raw = yaml.safe_load(args.config.read_text()) if args.config.suffix in ('.yml','.yaml') else json.loads(args.config.read_text())
        params.update(raw)
    if args.preset:
        params.update(PRESETS[args.preset])
    # override individual
    for k in ['algo','size','seed','roughness','octaves','persistence','lacunarity','scale']:
        v = getattr(args, k)
        if v is not None:
            params[k] = v
    # erosion passes
    if args.preset_pass in ('thermal','both') and args.therm_iters>0:
        params['thermal_iters'] = args.therm_iters; params['talus_angle']=args.talus
    if args.preset_pass in ('hydraulic','both') and args.hydro_iters>0:
        params['hydro_iters'] = args.hydro_iters; params['rain_amount']=args.rain

    seeds = args.batch_seeds if args.batch_seeds else [params.get('seed',42)]
    out_dir = Path('tweak_outputs'); out_dir.mkdir(exist_ok=True)

    for sd in seeds:
        params['seed'] = sd
        desc = f"{params['algo']}_s{sd}"
        print(f"Generating {desc}...")
        Z = generate_heightmap(**params)
        # Heightmap
        if args.save_heightmap:
            np.save(out_dir/f"{desc}_height.npy", Z)
        # Biomes
        if args.save_biomes:
            slope = compute_slope(Z); wet=compute_wetness(Z)
            bmap = assign_biomes(Z,slope,wet)
            img = biome_colormap(bmap)
            plt.imsave(out_dir/f"{desc}_biomes.png", img)
        # Spectrum
        if args.save_spectrum:
            from scipy.fftpack import fftshift,fft2
            F=fftshift(fft2(Z)); P=abs(F)**2
            freqs=np.arange(P.shape[0]//2)
            ps = [P.flatten()[...,]] # dummy
        # Always save rendered height.png
        plt.figure(); plt.imshow(Z,cmap=args.palette); plt.axis('off')
        plt.tight_layout(pad=0); plt.savefig(out_dir/f"{desc}_terrain.png",dpi=200)
    print(f"All outputs in {out_dir.resolve()}")

```

terrafract/__main__.py:
```
#!/usr/bin/env python3
"""Graphical launcher for TerraFract ‚Äì three large, self‚Äëexplaining tiles."""
from __future__ import annotations
import sys, os, tempfile, webbrowser
import numpy as np
from PySide6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QPushButton, QFileDialog,
    QDialog, QFormLayout, QComboBox, QSpinBox, QLabel, QHBoxLayout,
    QProgressBar, QMessageBox
)
from PySide6.QtCore import Qt, QThread, Signal

from terrafract.heightmap_generators import generate_heightmap
from terrafract.fractal_workbench import FractalWorkbench
from terrafract.stretch_goals import create_erosion_timelapse

# ------------------------------- presets (shared with CLI)
PRESETS = {
    "Mountains": {"algorithm": "diamond-square", "roughness": 1.2},
    "Hills":     {"algorithm": "fbm", "octaves": 4, "persistence": 0.6, "scale": 80},
    "Islands":   {"algorithm": "diamond-square", "roughness": 0.8},
    "Fjords":    {"algorithm": "fbm", "octaves": 6, "persistence": 0.4, "scale": 40},
}

ICONS = {"Quick Terrain": "üó∫Ô∏è", "Workbench": "üßë‚Äçüíª", "Timelapse": "‚è±Ô∏è"}

# ------------------------------------------------------------------ threads
class _TimelapseThread(QThread):
    progress = Signal(int)   # 0‚Äë100
    finished = Signal(str)

    def __init__(self, Z, steps, interval, out_path):
        super().__init__()
        self.Z, self.steps, self.interval, self.out = Z, steps, interval, out_path

    def run(self):
        create_erosion_timelapse(self.Z, steps=self.steps, interval=self.interval,
                                 therm_iters=1, hydro_iters=1, output_path=self.out)
        self.progress.emit(100)
        self.finished.emit(self.out)

# ------------------------------------------------------------------ dialogs
class _QuickTerrainDlg(QDialog):
    """Pick preset / seed / size ‚Äì> PNG."""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Quick Terrain")
        f = QFormLayout(self)

        self.cb = QComboBox(); self.cb.addItems(PRESETS)
        f.addRow("Preset:", self.cb)
        self.seed = QSpinBox(); self.seed.setRange(0, 9999)
        f.addRow("Seed:", self.seed)
        self.size = QSpinBox(); self.size.setRange(33, 1025); self.size.setValue(257)
        f.addRow("Size:", self.size)

        self.path_lbl = QLabel("terrain.png")
        choose = QPushButton("Change‚Ä¶"); choose.clicked.connect(self._pick)
        hl = QHBoxLayout(); hl.addWidget(self.path_lbl); hl.addWidget(choose)
        f.addRow("Export:", hl)

        ok = QPushButton("Generate"); ok.clicked.connect(self.accept)
        f.addRow(ok)

    def _pick(self):
        p, _ = QFileDialog.getSaveFileName(self, "Save PNG", "terrain.png", "PNG (*.png)")
        if p: self.path_lbl.setText(p)

    # helpers
    @property
    def params(self):
        p = PRESETS[self.cb.currentText()].copy()
        p.update(size=self.size.value(), seed=self.seed.value())
        return p
    @property
    def out_path(self):
        return self.path_lbl.text()

# ------------------------------------------------------------------ main win
class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("TerraFract")
        self.resize(520, 380)
        v = QVBoxLayout(self); v.setAlignment(Qt.AlignCenter)

        for label in ("Quick Terrain", "Workbench", "Timelapse"):
            btn = QPushButton(f"{ICONS[label]}  {label}")
            btn.setMinimumHeight(70)
            btn.clicked.connect(getattr(self, f"_on_{label.split()[0].lower()}"))
            v.addWidget(btn)

    # ---------- tile callbacks
    def _on_quick(self):  # Quick Terrain
        dlg = _QuickTerrainDlg(self)
        if dlg.exec() != QDialog.Accepted: return
        Z = generate_heightmap(**dlg.params)
        import matplotlib.pyplot as plt
        plt.imsave(dlg.out_path, Z, cmap="terrain")
        if QMessageBox.question(self, "Saved", f"Saved to {dlg.out_path}\nOpen it?",
                                 QMessageBox.Yes | QMessageBox.No) == QMessageBox.Yes:
            webbrowser.open(dlg.out_path)

    def _on_workbench(self):
        self._wb = FractalWorkbench(); self._wb.show()  # keep ref

    def _on_timelapse(self):
        path, _ = QFileDialog.getSaveFileName(self, "Save timelapse", "timelapse.mp4", "MP4 (*.mp4)")
        if not path: return
        Z = np.random.rand(128,128)
        self._thread = _TimelapseThread(Z, steps=60, interval=100, out_path=path)

        dlg = QDialog(self); dlg.setWindowTitle("Rendering timelapse‚Ä¶")
        l = QVBoxLayout(dlg)
        bar = QProgressBar(); bar.setRange(0,100); l.addWidget(bar)
        cancel = QPushButton("Cancel"); l.addWidget(cancel)
        cancel.clicked.connect(self._thread.terminate)
        self._thread.progress.connect(bar.setValue)
        self._thread.finished.connect(lambda p: (dlg.accept(), webbrowser.open(p)))
        self._thread.start(); dlg.exec()

# ------------------------------------------------------------------ bootstrap
def main():
    app = QApplication(sys.argv)
    win = MainWindow()
    win.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
```

tests/test_terrafract.py:
```
import numpy as np
import pytest

from terrafract import (
    compute_slope,
    compute_wetness,
    assign_biomes,
    biome_colormap,
    synthesize_biomes,
    generate_heightmap,
    thermal_erosion,
    hydraulic_erosion,
    voronoi_cliffs,
    reverse_engineer_heightmap,
    estimate_spectral_exponent,
    equalize_mean,
    radial_power_spectrum,
)

def test_compute_slope_constant():
    Z = np.ones((10, 10)) * 0.5
    s = compute_slope(Z)
    assert s.shape == Z.shape
    assert np.allclose(s, 0)


def test_compute_wetness_monotonic():
    # gradient from 0 to 1
    Z = np.linspace(0, 1, 100).reshape(10, 10)
    w = compute_wetness(Z, smoothing_sigma=1)
    assert w.shape == Z.shape
    # lower Z should have higher wetness
    assert w[0,0] > w[-1,-1]


def test_assign_biomes_and_colormap():
    Z = np.array([[0.1, 0.25, 0.5, 0.85, 0.95]])
    slope = np.zeros_like(Z)
    wet = np.zeros_like(Z)
    b = assign_biomes(Z, slope, wet)
    # expect water(0), sand(1), grass(2), forest(3), rock(4), snow(5)
    assert list(b.ravel()) == [0, 1, 2, 3, 4, 5][:len(b.ravel())]
    rgb = biome_colormap(b)
    assert rgb.shape == (1, 5, 3)


def test_synthesize_biomes_consistency():
    Z = np.random.rand(32,32)
    rgb, b = synthesize_biomes(Z)
    assert rgb.shape == (32,32,3)
    assert b.shape == (32,32)


def test_generate_heightmap_ds_and_fbm():
    Z1 = generate_heightmap('diamond-square', size=33, seed=0, roughness=0.5)
    assert Z1.shape == (33,33)
    assert Z1.min() >= 0 and Z1.max() <= 1
    Z2 = generate_heightmap('fbm', size=32, seed=0, octaves=3, persistence=0.5, lacunarity=2.0, scale=10)
    assert Z2.shape == (32,32)
    assert Z2.min() >= 0 and Z2.max() <= 1


@pytest.mark.slow
def test_post_processing_preserves_shape_and_norm():
    Z = np.random.rand(20,20)
    Zt = thermal_erosion(Z, iterations=5, talus_angle=0.01)
    Zh = hydraulic_erosion(Z, iterations=5, rain_amount=0.01)
    Zv = voronoi_cliffs(Z, num_sites=5, ridge_height=0.2)
    for Zp in (Zt, Zh, Zv):
        assert Zp.shape == Z.shape
        assert np.all(Zp >= 0) and np.all(Zp <= 1)


def test_reverse_engineering_fbm():
    # create a synthetic map
    np.random.seed(1)
    Z_real = generate_heightmap('fbm', size=64, seed=1, octaves=4, persistence=0.6, lacunarity=2.5, scale=20)
    params, Z_synth = reverse_engineer_heightmap(Z_real, algorithm='fbm', seed=1)
    assert 'H' in params
    assert Z_synth.shape == Z_real.shape


def test_estimate_spectral_exponent():
    Z = np.random.rand(64,64)
    beta, intercept = estimate_spectral_exponent(Z)
    assert isinstance(beta, float)


def test_comparative_study_helpers():
    Z = np.random.rand(50,50)
    Z_eq = equalize_mean(Z, target_mean=0.4)
    assert abs(Z_eq.mean() - 0.4) < 1e-2
    f, P = radial_power_spectrum(Z)
    assert len(f) == len(P)
    d = box_count_dim(Z)
    assert isinstance(d, float)


if __name__ == '__main__':
    pytest.main()

```



Now implement 